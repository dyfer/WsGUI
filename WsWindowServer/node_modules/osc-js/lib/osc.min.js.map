{"version":3,"file":"osc.min.js","sources":["../src/common/utils.js","../src/common/helpers.js","../src/atomic.js","../src/atomic/int32.js","../src/atomic/string.js","../src/atomic/timetag.js","../src/atomic/blob.js","../src/atomic/float32.js","../src/message.js","../src/bundle.js","../src/packet.js","../src/events.js","../src/plugin/dgram.js","../src/plugin/bridge.js","../src/plugin/wsclient.js","../src/plugin/wsserver.js","../src/osc.js"],"sourcesContent":["/**\n * Check if given object is an integer number\n * @param {*} n\n * @return {boolean}\n */\nexport function isInt(n) {\n  return Number(n) === n && n % 1 === 0\n}\n\n/**\n * Check if given object is a float number\n * @param {*} n\n * @return {boolean}\n */\nexport function isFloat(n) {\n  return Number(n) === n && n % 1 !== 0\n}\n\n/**\n * Check if given object is a string\n * @param {*} n\n * @return {boolean}\n */\nexport function isString(n) {\n  return typeof n === 'string'\n}\n\n/**\n * Check if given object is an array\n * @param {*} n\n * @return {boolean}\n */\nexport function isArray(n) {\n  return Object.prototype.toString.call(n) === '[object Array]'\n}\n\n/**\n * Check if given object is an object\n * @param {*} n\n * @return {boolean}\n */\nexport function isObject(n) {\n  return Object.prototype.toString.call(n) === '[object Object]'\n}\n\n/**\n * Check if given object is a function\n * @param {*} n\n * @return {boolean}\n */\nexport function isFunction(n) {\n  return typeof n === 'function'\n}\n\n/**\n * Check if given object is a Uint8Array\n * @param {*} n\n * @return {boolean}\n */\nexport function isBlob(n) {\n  return n instanceof Uint8Array\n}\n\n/**\n * Check if given object is a Date\n * @param {*} n\n * @return {boolean}\n */\nexport function isDate(n) {\n  return n instanceof Date\n}\n\n/**\n * Check if given object is undefined\n * @param {*} n\n * @return {boolean}\n */\nexport function isUndefined(n) {\n  return typeof n === 'undefined'\n}\n\n/**\n * Return the next multiple of four\n * @param {number} n\n */\nexport function pad(n) {\n  return (n + 3) & ~0x03\n}\n\n/**\n * Checks if environment provides a feature\n * @param {string} name Name of needed feature\n * @return {boolean}\n */\nexport function hasProperty(name) {\n  return Object.prototype.hasOwnProperty.call(\n    (typeof global !== 'undefined' ? global : window), // eslint-disable-line no-undef\n    name\n  )\n}\n\n/**\n * Wrap binary data in DataView\n * @param {*} obj\n * @return {DataView}\n */\nexport function dataView(obj) {\n  if (obj.buffer) {\n    return new DataView(obj.buffer)\n  } else if (obj instanceof ArrayBuffer) {\n    return new DataView(obj)\n  }\n\n  return new DataView(new Uint8Array(obj))\n}\n","import {\n  isArray,\n  isBlob,\n  isFloat,\n  isInt,\n  isString,\n} from './utils'\n\n/**\n * Checks type of given object and returns the regarding OSC\n * Type tag character\n * @param {*} item Any object\n * @return {string} OSC Type tag character\n */\nexport function typeTag(item) {\n  if (isInt(item)) {\n    return 'i'\n  } else if (isFloat(item)) {\n    return 'f'\n  } else if (isString(item)) {\n    return 's'\n  } else if (isBlob(item)) {\n    return 'b'\n  }\n\n  throw new Error('OSC typeTag() found unknown value type')\n}\n\n/**\n * Sanitizes an OSC-ready Address Pattern\n * @param {array|string} obj Address as string or array of strings\n * @return {string} Corrected address string\n *\n * @example\n * // all calls return '/test/path' string:\n * prepareAddress('test/path')\n * prepareAddress('/test/path/')\n * prepareAddress([test, path])\n */\nexport function prepareAddress(obj) {\n  let address = ''\n\n  if (isArray(obj)) {\n    return `/${obj.join('/')}`\n  } else if (isString(obj)) {\n    address = obj\n\n    // remove slash at ending of address\n    if (address.length > 1 && address[address.length - 1] === '/') {\n      address = address.slice(0, address.length - 1)\n    }\n\n    // add slash at beginning of address\n    if (address.length > 1 && address[0] !== '/') {\n      address = `/${address}`\n    }\n\n    return address\n  }\n\n  throw new Error('OSC prepareAddress() needs addresses of type array or string')\n}\n\n/**\n * Make an OSC address pattern javascript-regex-ready\n * @param {string} str OSC address pattern\n * @return {string} Javascript RegEx string\n */\nexport function prepareRegExPattern(str) {\n  let pattern\n\n  if (!(isString(str))) {\n    throw new Error('OSC prepareRegExPattern() needs strings')\n  }\n\n  pattern = str.replace(/\\./g, '\\\\.')\n  pattern = pattern.replace(/\\(/g, '\\\\(')\n  pattern = pattern.replace(/\\)/g, '\\\\)')\n\n  pattern = pattern.replace(/\\{/g, '(')\n  pattern = pattern.replace(/\\}/g, ')')\n  pattern = pattern.replace(/,/g, '|')\n\n  pattern = pattern.replace(/\\[!/g, '[^')\n\n  pattern = pattern.replace(/\\?/g, '.')\n  pattern = pattern.replace(/\\*/g, '.*')\n\n  return pattern\n}\n\n/**\n * Holds a list of items and helps to merge them\n * into a single array of packed binary data\n */\nexport default class EncodeHelper {\n  /**\n   * Create a new EncodeHelper instance\n   */\n  constructor() {\n    /** @type {array} data */\n    this.data = []\n    /** @type {number} byteLength */\n    this.byteLength = 0\n  }\n\n  /**\n   * Packs an item and adds it to the list\n   * @param {*} item Any object\n   * @return {EncodeHelper}\n   */\n  add(item) {\n    const buffer = item.pack()\n    this.byteLength += buffer.byteLength\n    this.data.push(buffer)\n\n    return this\n  }\n\n  /**\n   * Merge all added items into one Uint8Array\n   * @return {Uint8Array} Merged binary data array of all items\n   */\n  merge() {\n    const result = new Uint8Array(this.byteLength)\n    let offset = 0\n\n    this.data.forEach((data) => {\n      result.set(data, offset)\n      offset += data.byteLength\n    })\n\n    return result\n  }\n}\n","import { isUndefined } from './common/utils'\n\n/**\n * Base class for OSC Atomic Data Types\n */\nexport default class Atomic {\n  /**\n   * Create an Atomic instance\n   * @param {*} [value] Initial value of any type\n   */\n  constructor(value) {\n    /** @type {*} value */\n    this.value = value\n    /** @type {number} offset */\n    this.offset = 0\n  }\n\n  /**\n   * Interpret the given value of this entity as packed binary data\n   * @param {string} method The DataView method to write to the ArrayBuffer\n   * @param {number} byteLength Size of array in bytes\n   * @return {Uint8Array} Packed binary data\n   */\n  pack(method, byteLength) {\n    if (!(method && byteLength)) {\n      throw new Error('OSC Atomic cant\\'t be packed without given method or byteLength')\n    }\n\n    const data = new Uint8Array(byteLength)\n    const dataView = new DataView(data.buffer)\n\n    if (isUndefined(this.value)) {\n      throw new Error('OSC Atomic cant\\'t be encoded with empty value')\n    }\n\n    // use DataView to write to ArrayBuffer\n    dataView[method](this.offset, this.value, false)\n\n    // always return binary Uint8Array after packing\n    return data\n  }\n\n  /**\n   * Unpack binary data from DataView according to the given format\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {string} method The DataView method to read the format from the ArrayBuffer\n   * @param {number} byteLength Size of array in bytes\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, method, byteLength, initialOffset = 0) {\n    if (!(dataView && method && byteLength)) {\n      throw new Error('OSC Atomic cant\\'t be unpacked without given dataView, method or byteLength')\n    }\n\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Atomic expects an instance of type DataView')\n    }\n\n    // use DataView to read from ArrayBuffer and add offset\n    this.value = dataView[method](initialOffset, false)\n    this.offset = initialOffset + byteLength\n\n    // always return offset number after unpacking\n    return this.offset\n  }\n}\n","import { isInt } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * 32-bit big-endian two's complement integer OSC Atomic Data Type\n */\nexport default class AtomicInt32 extends Atomic {\n  /**\n   * Create an AtomicInt32 instance\n   * @param {number} [value] Initial integer value\n   */\n  constructor(value) {\n    if (value && !isInt(value)) {\n      throw new Error('OSC AtomicInt32 constructor expects value of type number')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given number as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    return super.pack('setInt32', 4)\n  }\n\n  /**\n   * Unpack binary data from DataView and read a Int32 number\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    return super.unpack(dataView, 'getInt32', 4, initialOffset)\n  }\n}\n","import {\n  hasProperty,\n  isString,\n  isUndefined,\n  pad,\n} from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/** Slice size of large strings for fallback method */\nconst STR_SLICE_SIZE = 65537\n\n/** Text encoding format */\nconst STR_ENCODING = 'utf-8'\n\n/**\n * Helper method to decode a string using different methods depending on environment\n * @param {array} charCodes Array of char codes\n * @return {string} Decoded string\n */\nfunction charCodesToString(charCodes) {\n  // Use these methods to be able to convert large strings\n  if (hasProperty('Buffer')) {\n    return Buffer.from(charCodes).toString(STR_ENCODING)\n  } else if (hasProperty('TextDecoder')) {\n    return new TextDecoder(STR_ENCODING) // eslint-disable-line no-undef\n      .decode(new Int8Array(charCodes))\n  }\n\n  // Fallback method\n  let str = ''\n\n  for (let i = 0; i < charCodes.length; i += STR_SLICE_SIZE) {\n    str += String.fromCharCode.apply(\n      null,\n      charCodes.slice(i, i + STR_SLICE_SIZE)\n    )\n  }\n\n  return str\n}\n\n/**\n * A sequence of non-null ASCII characters OSC Atomic Data Type\n */\nexport default class AtomicString extends Atomic {\n  /**\n   * Create an AtomicString instance\n   * @param {string} [value] Initial string value\n   */\n  constructor(value) {\n    if (value && !isString(value)) {\n      throw new Error('OSC AtomicString constructor expects value of type string')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given string as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (isUndefined(this.value)) {\n      throw new Error('OSC AtomicString can not be encoded with empty value')\n    }\n\n    // add 0-3 null characters for total number of bits a multiple of 32\n    const terminated = `${this.value}\\u0000`\n    const byteLength = pad(terminated.length)\n\n    const buffer = new Uint8Array(byteLength)\n\n    for (let i = 0; i < terminated.length; i += 1) {\n      buffer[i] = terminated.charCodeAt(i)\n    }\n\n    return buffer\n  }\n\n  /**\n   * Unpack binary data from DataView and read a string\n   * @param {DataView} dataView The DataView holding the binary representation of the string\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC AtomicString expects an instance of type DataView')\n    }\n\n    let offset = initialOffset\n    let charcode\n    const charCodes = []\n\n    for (; offset < dataView.byteLength; offset += 1) {\n      charcode = dataView.getUint8(offset)\n\n      // check for terminating null character\n      if (charcode !== 0) {\n        charCodes.push(charcode)\n      } else {\n        offset += 1\n        break\n      }\n    }\n\n    if (offset === dataView.length) {\n      throw new Error('OSC AtomicString found a malformed OSC string')\n    }\n\n    /** @type {number} offset */\n    this.offset = pad(offset)\n    /** @type {string} value */\n    this.value = charCodesToString(charCodes)\n\n    return this.offset\n  }\n}\n","import {\n  isDate,\n  isInt,\n  isUndefined,\n} from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/** 70 years in seconds */\nexport const SECONDS_70_YEARS = 2208988800\n/** 2^32 */\nexport const TWO_POWER_32 = 4294967296\n\n/**\n * Timetag helper class for representing NTP timestamps\n * and conversion between them and javascript representation\n */\nexport class Timetag {\n  /**\n   * Create a Timetag instance\n   * @param {number} [seconds=0] Initial NTP *seconds* value\n   * @param {number} [fractions=0] Initial NTP *fractions* value\n   */\n  constructor(seconds = 0, fractions = 0) {\n    if (!(isInt(seconds) && isInt(fractions))) {\n      throw new Error('OSC Timetag constructor expects values of type integer number')\n    }\n\n    /** @type {number} seconds */\n    this.seconds = seconds\n    /** @type {number} fractions */\n    this.fractions = fractions\n  }\n\n  /**\n   * Converts from NTP to JS representation and back\n   * @param {number} [milliseconds] Converts from JS milliseconds to NTP.\n   * Leave empty for converting from NTP to JavaScript representation\n   * @return {number} Javascript timestamp\n   */\n  timestamp(milliseconds) {\n    let seconds\n\n    if (typeof milliseconds === 'number') {\n      seconds = milliseconds / 1000\n      const rounded = Math.floor(seconds)\n\n      this.seconds = rounded + SECONDS_70_YEARS\n      this.fractions = Math.round(TWO_POWER_32 * (seconds - rounded))\n\n      return milliseconds\n    }\n\n    seconds = this.seconds - SECONDS_70_YEARS\n    return (seconds + Math.round(this.fractions / TWO_POWER_32)) * 1000\n  }\n}\n\n/**\n * 64-bit big-endian fixed-point time tag, semantics\n * defined below OSC Atomic Data Type\n */\nexport default class AtomicTimetag extends Atomic {\n  /**\n   * Create a AtomicTimetag instance\n   * @param {number|Timetag|Date} [value] Initial date, leave empty if\n   * you want it to be the current date\n   */\n  constructor(value = Date.now()) {\n    let timetag = new Timetag()\n\n    if (value instanceof Timetag) {\n      timetag = value\n    } else if (isInt(value)) {\n      timetag.timestamp(value)\n    } else if (isDate(value)) {\n      timetag.timestamp(value.getTime())\n    }\n\n    super(timetag)\n  }\n\n  /**\n   * Interpret the given timetag as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (isUndefined(this.value)) {\n      throw new Error('OSC AtomicTimetag can not be encoded with empty value')\n    }\n\n    const { seconds, fractions } = this.value\n    const data = new Uint8Array(8)\n    const dataView = new DataView(data.buffer)\n\n    dataView.setInt32(0, seconds, false)\n    dataView.setInt32(4, fractions, false)\n\n    return data\n  }\n\n  /**\n   * Unpack binary data from DataView and read a timetag\n   * @param {DataView} dataView The DataView holding the binary representation of the timetag\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC AtomicTimetag expects an instance of type DataView')\n    }\n\n    const seconds = dataView.getUint32(initialOffset, false)\n    const fractions = dataView.getUint32(initialOffset + 4, false)\n\n    /** @type {Timetag} value */\n    this.value = new Timetag(seconds, fractions)\n    /** @type {number} offset */\n    this.offset = initialOffset + 8\n\n    return this.offset\n  }\n}\n","import {\n  isBlob,\n  isUndefined,\n  pad,\n} from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * 8-bit bytes of arbitrary binary data OSC Atomic Data Type\n */\nexport default class AtomicBlob extends Atomic {\n  /**\n   * Create an AtomicBlob instance\n   * @param {Uint8Array} [value] Binary data\n   */\n  constructor(value) {\n    if (value && !isBlob(value)) {\n      throw new Error('OSC AtomicBlob constructor expects value of type Uint8Array')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given blob as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (isUndefined(this.value)) {\n      throw new Error('OSC AtomicBlob can not be encoded with empty value')\n    }\n\n    const byteLength = pad(this.value.byteLength)\n    const data = new Uint8Array(byteLength + 4)\n    const dataView = new DataView(data.buffer)\n\n    // an int32 size count\n    dataView.setInt32(0, this.value.byteLength, false)\n    // followed by 8-bit bytes of arbitrary binary data\n    data.set(this.value, 4)\n\n    return data\n  }\n\n  /**\n   * Unpack binary data from DataView and read a blob\n   * @param {DataView} dataView The DataView holding the binary representation of the blob\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC AtomicBlob expects an instance of type DataView')\n    }\n\n    const byteLength = dataView.getInt32(initialOffset, false)\n\n    /** @type {Uint8Array} value */\n    this.value = new Uint8Array(dataView.buffer, initialOffset + 4, byteLength)\n    /** @type {number} offset */\n    this.offset = pad(initialOffset + 4 + byteLength)\n\n    return this.offset\n  }\n}\n","import { isFloat } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * 32-bit big-endian IEEE 754 floating point number OSC Atomic Data Type\n */\nexport default class AtomicFloat32 extends Atomic {\n  /**\n   * Create an AtomicFloat32 instance\n   * @param {number} [value] Float number\n   */\n  constructor(value) {\n    if (value && !isFloat(value)) {\n      throw new Error('OSC AtomicFloat32 constructor expects value of type float')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given number as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    return super.pack('setFloat32', 4)\n  }\n\n  /**\n   * Unpack binary data from DataView and read a Float32 number\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    return super.unpack(dataView, 'getFloat32', 4, initialOffset)\n  }\n}\n","import {\n  isArray,\n  isBlob,\n  isFloat,\n  isInt,\n  isString,\n  isUndefined,\n} from './common/utils'\n\nimport Helper, { typeTag, prepareAddress } from './common/helpers'\n\nimport AtomicBlob from './atomic/blob'\nimport AtomicFloat32 from './atomic/float32'\nimport AtomicInt32 from './atomic/int32'\nimport AtomicString from './atomic/string'\n\n/**\n * An OSC message consists of an OSC Address Pattern followed\n * by an OSC Type Tag String followed by zero or more OSC Arguments\n */\nexport default class Message {\n  /**\n   * Create a Message instance\n   * @param {array|string} args Address\n   * @param {...*} args OSC Atomic Data Types\n   *\n   * @example\n   * const message = new Message(['test', 'path'], 50, 100.52, 'test')\n   *\n   * @example\n   * const message = new Message('/test/path', 51.2)\n   */\n  constructor(...args) {\n    /**\n     * @type {number} offset\n     * @private\n     */\n    this.offset = 0\n    /** @type {string} address */\n    this.address = ''\n    /** @type {string} types */\n    this.types = ''\n    /** @type {array} args */\n    this.args = []\n\n    if (args.length > 0) {\n      if (!(isString(args[0]) || isArray(args[0]))) {\n        throw new Error('OSC Message constructor first argument (address) must be a string or array')\n      }\n\n      this.address = prepareAddress(args.shift())\n      this.types = args.map(item => typeTag(item)).join('')\n      this.args = args\n    }\n  }\n\n  /**\n   * Add an OSC Atomic Data Type to the list of elements\n   * @param {*} item\n   */\n  add(item) {\n    if (isUndefined(item)) {\n      throw new Error('OSC Message needs a valid OSC Atomic Data Type')\n    }\n\n    this.args.push(item)\n    this.types += typeTag(item)\n  }\n\n  /**\n   * Interpret the Message as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (this.address.length === 0 || this.address[0] !== '/') {\n      throw new Error('OSC Message has an invalid address')\n    }\n\n    const encoder = new Helper()\n\n    // OSC Address Pattern and Type string\n    encoder.add(new AtomicString(this.address))\n    encoder.add(new AtomicString(`,${this.types}`))\n\n    // followed by zero or more OSC Arguments\n    if (this.args.length > 0) {\n      let argument\n\n      this.args.forEach((value) => {\n        if (isInt(value)) {\n          argument = new AtomicInt32(value)\n        } else if (isFloat(value)) {\n          argument = new AtomicFloat32(value)\n        } else if (isString(value)) {\n          argument = new AtomicString(value)\n        } else if (isBlob(value)) {\n          argument = new AtomicBlob(value)\n        } else {\n          throw new Error('OSC Message found unknown argument type')\n        }\n\n        encoder.add(argument)\n      })\n    }\n\n    return encoder.merge()\n  }\n\n  /**\n   * Unpack binary data to read a Message\n   * @param {DataView} dataView The DataView holding the binary representation of a Message\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Message expects an instance of type DataView.')\n    }\n\n    // read address pattern\n    const address = new AtomicString()\n    address.unpack(dataView, initialOffset)\n\n    // read type string\n    const types = new AtomicString()\n    types.unpack(dataView, address.offset)\n\n    if (address.value.length === 0 || address.value[0] !== '/') {\n      throw new Error('OSC Message found malformed or missing address string')\n    }\n\n    if (types.value.length === 0 && types.value[0] !== ',') {\n      throw new Error('OSC Message found malformed or missing type string')\n    }\n\n    let { offset } = types\n    let next\n    let type\n\n    const args = []\n\n    // read message arguments (OSC Atomic Data Types)\n    for (let i = 1; i < types.value.length; i += 1) {\n      type = types.value[i]\n\n      if (type === 'i') {\n        next = new AtomicInt32()\n      } else if (type === 'f') {\n        next = new AtomicFloat32()\n      } else if (type === 's') {\n        next = new AtomicString()\n      } else if (type === 'b') {\n        next = new AtomicBlob()\n      } else {\n        throw new Error('OSC Message found non-standard argument type')\n      }\n\n      offset = next.unpack(dataView, offset)\n      args.push(next.value)\n    }\n\n    this.offset = offset\n    this.address = address.value\n    this.types = types.value\n    this.args = args\n\n    return this.offset\n  }\n}\n","import EncodeHelper from './common/helpers'\nimport { isArray, isInt } from './common/utils'\n\nimport AtomicInt32 from './atomic/int32'\nimport AtomicString from './atomic/string'\nimport AtomicTimetag from './atomic/timetag'\nimport Message from './message'\n\n/** OSC Bundle string */\nexport const BUNDLE_TAG = '#bundle'\n\n/**\n * An OSC Bundle consist of a Timetag and one or many Bundle Elements.\n * The elements are either OSC Messages or more OSC Bundles\n */\nexport default class Bundle {\n  /**\n   * Create a Bundle instance\n   * @param {...*} [args] Timetag and elements. See examples for options\n   *\n   * @example\n   * const bundle = new Bundle(new Date() + 500)\n   *\n   * @example\n   * const message = new Message('/test/path', 51.2)\n   * const anotherBundle = new Bundle([message], Date.now() + 1500)\n   *\n   * @example\n   * const message = new Message('/test/path', 51.2)\n   * const anotherMessage = new Message('/test/message', 'test', 12)\n   * const anotherBundle = new Bundle(message, anotherMessage)\n   */\n  constructor(...args) {\n    /**\n     * @type {number} offset\n     * @private\n     */\n    this.offset = 0\n    /** @type {AtomicTimetag} timetag */\n    this.timetag = new AtomicTimetag()\n    /** @type {array} bundleElements */\n    this.bundleElements = []\n\n    if (args.length > 0) {\n      // first argument is an Date or js timestamp (number)\n      if (args[0] instanceof Date || isInt(args[0])) {\n        this.timetag = new AtomicTimetag(args[0])\n      } else if (isArray(args[0])) {\n        // first argument is an Array of Bundle elements\n        args[0].forEach((item) => {\n          this.add(item)\n        })\n\n        // second argument is an Date or js timestamp (number)\n        if (args.length > 1 && (args[1] instanceof Date || isInt(args[0]))) {\n          this.timetag = new AtomicTimetag(args[1])\n        }\n      } else {\n        // take all arguments as Bundle elements\n        args.forEach((item) => {\n          this.add(item)\n        })\n      }\n    }\n  }\n\n  /**\n   * Take a JavaScript timestamp to set the Bundle's timetag\n   * @param {number} ms JS timestamp in milliseconds\n   *\n   * @example\n   * const bundle = new Bundle()\n   * bundle.timestamp(Date.now() + 5000) // in 5 seconds\n   */\n  timestamp(ms) {\n    if (!isInt(ms)) {\n      throw new Error('OSC Bundle needs an integer for setting the timestamp')\n    }\n\n    this.timetag = new AtomicTimetag(ms)\n  }\n\n  /**\n   * Add a Message or Bundle to the list of elements\n   * @param {Bundle|Message} item\n   */\n  add(item) {\n    if (!(item instanceof Message || item instanceof Bundle)) {\n      throw new Error('OSC Bundle contains only Messages and Bundles')\n    }\n\n    this.bundleElements.push(item)\n  }\n\n  /**\n   * Interpret the Bundle as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    const encoder = new EncodeHelper()\n\n    // an OSC Bundle consists of the OSC-string \"#bundle\"\n    encoder.add(new AtomicString(BUNDLE_TAG))\n\n    // followed by an OSC Time Tag\n    if (!this.timetag) {\n      this.timetag = new AtomicTimetag()\n    }\n\n    encoder.add(this.timetag)\n\n    // followed by zero or more OSC Bundle Elements\n    this.bundleElements.forEach((item) => {\n      encoder.add(new AtomicInt32(item.pack().byteLength))\n      encoder.add(item)\n    })\n\n    return encoder.merge()\n  }\n\n  /**\n   * Unpack binary data to read a Bundle\n   * @param {DataView} dataView The DataView holding the binary representation of a Bundle\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Bundle expects an instance of type DataView')\n    }\n\n    // read the beginning bundle string\n    const parentHead = new AtomicString()\n    parentHead.unpack(dataView, initialOffset)\n\n    if (parentHead.value !== BUNDLE_TAG) {\n      throw new Error('OSC Bundle does not contain a valid #bundle head')\n    }\n\n    // read the timetag\n    const timetag = new AtomicTimetag()\n    let offset = timetag.unpack(dataView, parentHead.offset)\n\n    // read the bundle elements\n    this.bundleElements = []\n\n    while (offset < dataView.byteLength) {\n      const head = new AtomicString()\n      const size = new AtomicInt32()\n\n      offset = size.unpack(dataView, offset)\n\n      // check if Packet is a Bundle or a Message\n      let item\n      head.unpack(dataView, offset)\n\n      if (head.value === BUNDLE_TAG) {\n        item = new Bundle()\n      } else {\n        item = new Message()\n      }\n\n      offset = item.unpack(dataView, offset)\n\n      this.bundleElements.push(item)\n    }\n\n    this.offset = offset\n    this.timetag = timetag\n\n    return this.offset\n  }\n}\n","import AtomicString from './atomic/string'\nimport Bundle, { BUNDLE_TAG } from './bundle'\nimport Message from './message'\n\n/**\n * The unit of transmission of OSC is an OSC Packet. The contents\n * of an OSC packet must be either an OSC Message or an OSC Bundle\n */\nexport default class Packet {\n  /**\n   * Create a Packet instance holding a Message or Bundle\n   * @param {Message|Bundle} [value] Initial Packet value\n   */\n  constructor(value) {\n    if (value && !(value instanceof Message || value instanceof Bundle)) {\n      throw new Error('OSC Packet value has to be Message or Bundle')\n    }\n\n    /** @type {Message|Bundle} value */\n    this.value = value\n    /**\n     * @type {number} offset\n     * @private\n     */\n    this.offset = 0\n  }\n\n  /**\n   * Packs the Packet value. This implementation is more like\n   * a wrapper due to OSC specifications, you could also skip the\n   * Packet and directly work with the Message or Bundle instance\n   * @return {Uint8Array} Packed binary data\n   *\n   * @example\n   * const message = new Message('/test/path', 21.5, 'test')\n   * const packet = new Packet(message)\n   * const packetBinary = packet.pack() // then send it via udp etc.\n   *\n   * // or skip the Packet for convenience\n   * const messageBinary = message.pack()\n   */\n  pack() {\n    if (!this.value) {\n      throw new Error('OSC Packet can not be encoded with empty body')\n    }\n\n    return this.value.pack()\n  }\n\n  /**\n   * Unpack binary data from DataView to read Messages or Bundles\n   * @param {DataView} dataView The DataView holding a binary representation of a Packet\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Packet expects an instance of type DataView')\n    }\n\n    if (dataView.byteLength % 4 !== 0) {\n      throw new Error('OSC Packet byteLength has to be a multiple of four')\n    }\n\n    const head = new AtomicString()\n    head.unpack(dataView, initialOffset)\n\n    let item\n\n    // check if Packet is a Bundle or a Message\n    if (head.value === BUNDLE_TAG) {\n      item = new Bundle()\n    } else {\n      item = new Message()\n    }\n\n    item.unpack(dataView, initialOffset)\n\n    this.offset = item.offset\n    this.value = item\n\n    return this.offset\n  }\n}\n","import {\n  dataView,\n  isArray,\n  isFunction,\n  isInt,\n  isString,\n} from './common/utils'\n\nimport {\n  prepareAddress,\n  prepareRegExPattern,\n} from './common/helpers'\n\nimport Bundle from './bundle'\nimport Message from './message'\nimport Packet from './packet'\n\n/**\n * Default options\n * @private\n */\nconst defaultOptions = {\n  discardLateMessages: false,\n}\n\n/**\n * EventHandler to notify listeners on matching OSC messages and\n * status changes of plugins\n */\nexport default class EventHandler {\n  /**\n   * Create an EventHandler instance\n   * @param {object} options Custom options\n   */\n  constructor(options) {\n    /**\n     * @type {object} options\n     * @private\n     */\n    this.options = Object.assign({}, defaultOptions, options)\n    /**\n     * @type {array} addressHandlers\n     * @private\n     */\n    this.addressHandlers = []\n    /**\n     * @type {object} eventHandlers\n     * @private\n     */\n    this.eventHandlers = {\n      open: [],\n      error: [],\n      close: [],\n    }\n    /**\n     * @type {number} uuid\n     * @private\n     */\n    this.uuid = 0\n  }\n\n  /**\n   * Internally used method to dispatch OSC Packets. Extracts\n   * given Timetags and dispatches them accordingly\n   * @param {Packet} packet\n   * @return {boolean} Success state\n   * @private\n   */\n  dispatch(packet) {\n    if (!(packet instanceof Packet)) {\n      throw new Error('OSC EventHander dispatch() accepts only arguments of type Packet')\n    }\n\n    if (!packet.value) {\n      throw new Error('OSC EventHander dispatch() can\\'t read empty Packets')\n    }\n\n    if (packet.value instanceof Bundle) {\n      const bundle = packet.value\n\n      return bundle.bundleElements.forEach((bundleItem) => {\n        if (bundleItem instanceof Bundle) {\n          if (bundle.timetag.value.timestamp() < bundleItem.timetag.value.timestamp()) {\n            throw new Error('OSC Bundle timestamp is older than the timestamp of enclosed Bundles')\n          }\n          return this.dispatch(bundleItem)\n        } else if (bundleItem instanceof Message) {\n          const message = bundleItem\n          return this.notify(\n            message.address,\n            message,\n            bundle.timetag.value.timestamp()\n          )\n        }\n\n        throw new Error('OSC EventHander dispatch() can\\'t dispatch unknown Packet value')\n      })\n    } else if (packet.value instanceof Message) {\n      const message = packet.value\n      return this.notify(message.address, message)\n    }\n\n    throw new Error('OSC EventHander dispatch() can\\'t dispatch unknown Packet value')\n  }\n\n  /**\n   * Internally used method to invoke listener callbacks. Uses regular\n   * expression pattern matching for OSC addresses\n   * @param {string} name OSC address or event name\n   * @param {*} [data] The data of the event\n   * @return {boolean} Success state\n   * @private\n   */\n  call(name, data) {\n    let success = false\n\n    // call event handlers\n    if (isString(name) && name in this.eventHandlers) {\n      this.eventHandlers[name].forEach((handler) => {\n        handler.callback(data)\n        success = true\n      })\n\n      return success\n    }\n\n    // call address handlers\n    const handlerKeys = Object.keys(this.addressHandlers)\n    const handlers = this.addressHandlers\n\n    handlerKeys.forEach((key) => {\n      let foundMatch = false\n\n      const regex = new RegExp(prepareRegExPattern(prepareAddress(name)), 'g')\n      const test = regex.test(key)\n\n      // found a matching address in our callback handlers\n      if (test && key.length === regex.lastIndex) {\n        foundMatch = true\n      }\n\n      if (!foundMatch) {\n        // try matching address from callback handlers (when given)\n        const reverseRegex = new RegExp(prepareRegExPattern(prepareAddress(key)), 'g')\n        const reverseTest = reverseRegex.test(name)\n\n        if (reverseTest && name.length === reverseRegex.lastIndex) {\n          foundMatch = true\n        }\n      }\n\n      if (foundMatch) {\n        handlers[key].forEach((handler) => {\n          handler.callback(data)\n          success = true\n        })\n      }\n    })\n\n    return success\n  }\n\n  /**\n   * Notify the EventHandler of incoming OSC messages or status\n   * changes (*open*, *close*, *error*). Handles OSC address patterns\n   * and executes timed messages. Use binary arrays when\n   * handling directly incoming network data. Packet's or Messages can\n   * also be used\n   * @param {...*} args\n   * The OSC address pattern / event name as string}. For convenience and\n   * Plugin API communication you can also use Message or Packet instances\n   * or ArrayBuffer, Buffer instances (low-level access). The latter will\n   * automatically be unpacked\n   * When using a string you can also pass on data as a second argument\n   * (any type). All regarding listeners will be notified with this data.\n   * As a third argument you can define a javascript timestamp (number or\n   * Date instance) for timed notification of the listeners.\n   * @return {boolean} Success state of notification\n   *\n   * @example\n   * const socket = dgram.createSocket('udp4')\n   * socket.on('message', (message) => {\n   *   this.notify(message)\n   * })\n   *\n   * @example\n   * this.notify('error', error.message)\n   *\n   * @example\n   * const message = new OSC.Message('/test/path', 55)\n   * this.notify(message)\n   *\n   * @example\n   * const message = new OSC.Message('/test/path', 55)\n   * // override timestamp\n   * this.notify(message.address, message, Date.now() + 5000)\n   */\n  notify(...args) {\n    if (args.length === 0) {\n      throw new Error('OSC EventHandler can not be called without any argument')\n    }\n\n    // check for incoming dispatchable OSC data\n    if (args[0] instanceof Packet) {\n      return this.dispatch(args[0])\n    } else if (args[0] instanceof Bundle || args[0] instanceof Message) {\n      return this.dispatch(new Packet(args[0]))\n    } else if (!isString(args[0])) {\n      const packet = new Packet()\n      packet.unpack(dataView(args[0]))\n      return this.dispatch(packet)\n    }\n\n    const name = args[0]\n\n    // data argument\n    let data = null\n\n    if (args.length > 1) {\n      data = args[1]\n    }\n\n    // timestamp argument\n    let timestamp = null\n\n    if (args.length > 2) {\n      if (isInt(args[2])) {\n        timestamp = args[2]\n      } else if (args[2] instanceof Date) {\n        timestamp = args[2].getTime()\n      } else {\n        throw new Error('OSC EventHandler timestamp has to be a number or Date')\n      }\n    }\n\n    // notify now or later\n    if (timestamp) {\n      const now = Date.now()\n\n      // is message outdated?\n      if (now > timestamp) {\n        if (!this.options.discardLateMessages) {\n          return this.call(name, data)\n        }\n      }\n\n      // notify later\n      const that = this\n\n      setTimeout(() => {\n        that.call(name, data)\n      }, timestamp - now)\n\n      return true\n    }\n\n    return this.call(name, data)\n  }\n\n  /**\n   * Subscribe to a new address or event you want to listen to\n   * @param {string} name The OSC address or event name\n   * @param {function} callback Callback function on notification\n   * @return {number} Subscription identifier (needed to unsubscribe)\n   */\n  on(name, callback) {\n    if (!(isString(name) || isArray(name))) {\n      throw new Error('OSC EventHandler accepts only strings or arrays for address patterns')\n    }\n\n    if (!isFunction(callback)) {\n      throw new Error('OSC EventHandler callback has to be a function')\n    }\n\n    // get next id\n    this.uuid += 1\n\n    // prepare handler\n    const handler = {\n      id: this.uuid,\n      callback,\n    }\n\n    // register event listener\n    if (isString(name) && name in this.eventHandlers) {\n      this.eventHandlers[name].push(handler)\n      return this.uuid\n    }\n\n    // register address listener\n    const address = prepareAddress(name)\n\n    if (!(address in this.addressHandlers)) {\n      this.addressHandlers[address] = []\n    }\n\n    this.addressHandlers[address].push(handler)\n\n    return this.uuid\n  }\n\n  /**\n   * Unsubscribe listener from event notification or address handler\n   * @param {string} name The OSC address or event name\n   * @param {number} subscriptionId Subscription id to identify the handler\n   * @return {boolean} Success state\n   */\n  off(name, subscriptionId) {\n    if (!(isString(name) || isArray(name))) {\n      throw new Error('OSC EventHandler accepts only strings or arrays for address patterns')\n    }\n\n    if (!isInt(subscriptionId)) {\n      throw new Error('OSC EventHandler subscription id has to be a number')\n    }\n\n    let key\n    let haystack\n\n    // event or address listener\n    if (isString(name) && name in this.eventHandlers) {\n      key = name\n      haystack = this.eventHandlers\n    } else {\n      key = prepareAddress(name)\n      haystack = this.addressHandlers\n    }\n\n    // remove the entry\n    if (key in haystack) {\n      return haystack[key].some((item, index) => {\n        if (item.id === subscriptionId) {\n          haystack[key].splice(index, 1)\n          return true\n        }\n\n        return false\n      })\n    }\n\n    return false\n  }\n}\n","const dgram = typeof __dirname !== 'undefined' ? require('dgram') : undefined\n\n/**\n * Status flags\n * @private\n */\nconst STATUS = {\n  IS_NOT_INITIALIZED: -1,\n  IS_CONNECTING: 0,\n  IS_OPEN: 1,\n  IS_CLOSING: 2,\n  IS_CLOSED: 3,\n}\n\n/**\n * Default options for open method\n * @private\n */\nconst defaultOpenOptions = {\n  host: 'localhost',\n  port: 41234,\n  exclusive: false,\n}\n\n/**\n * Default options for send method\n * @private\n */\nconst defaultSendOptions = {\n  host: 'localhost',\n  port: 41235,\n}\n\n/**\n * Default options\n * @private\n */\nconst defaultOptions = {\n  type: 'udp4',\n  open: defaultOpenOptions,\n  send: defaultSendOptions,\n}\n\n/**\n * Helper method to merge nested objects\n * @private\n */\nfunction mergeOptions(base, custom) {\n  return Object.assign({}, defaultOptions, base, custom, {\n    open: Object.assign({}, defaultOptions.open, base.open, custom.open),\n    send: Object.assign({}, defaultOptions.send, base.send, custom.send),\n  })\n}\n\n/**\n * OSC plugin for simple OSC messaging via udp client\n * and udp server\n */\nexport default class DatagramPlugin {\n  /**\n   * Create an OSC Plugin instance with given options. Defaults to\n   * localhost:41234 for server and localhost:41235 for client messaging\n   * @param {object} [options] Custom options\n   * @param {string} [options.type='udp4'] 'udp4' or 'udp6'\n   * @param {string} [options.open.host='localhost'] Hostname of udp server to bind to\n   * @param {number} [options.open.port=41234] Port of udp server to bind to\n   * @param {boolean} [options.open.exclusive=false] Exclusive flag\n   * @param {string} [options.send.host='localhost'] Hostname of udp client for messaging\n   * @param {number} [options.send.port=41235] Port of udp client for messaging\n   *\n   * @example\n   * const plugin = new OSC.DatagramPlugin({ send: { port: 9912 } })\n   * const osc = new OSC({ plugin: plugin })\n   */\n  constructor(customOptions = {}) {\n    if (!dgram) {\n      throw new Error('DatagramPlugin can not be used in browser context')\n    }\n\n    /**\n     * @type {object} options\n     * @private\n     */\n    this.options = mergeOptions({}, customOptions)\n\n    /**\n     * @type {object} socket\n     * @private\n     */\n    this.socket = dgram.createSocket(this.options.type)\n    /**\n     * @type {number} socketStatus\n     * @private\n     */\n    this.socketStatus = STATUS.IS_NOT_INITIALIZED\n\n    // register events\n    this.socket.on('message', (message) => {\n      this.notify(message)\n    })\n\n    this.socket.on('error', (error) => {\n      this.notify('error', error)\n    })\n\n    /**\n     * @type {function} notify\n     * @private\n     */\n    this.notify = () => {}\n  }\n\n  /**\n   * Internal method to hook into osc library's\n   * EventHandler notify method\n   * @param {function} fn Notify callback\n   * @private\n   */\n  registerNotify(fn) {\n    this.notify = fn\n  }\n\n  /**\n   * Returns the current status of the connection\n   * @return {number} Status ID\n   */\n  status() {\n    return this.socketStatus\n  }\n\n  /**\n   * Bind a udp socket to a hostname and port\n   * @param {object} [customOptions] Custom options\n   * @param {string} [customOptions.host='localhost'] Hostname of udp server to bind to\n   * @param {number} [customOptions.port=41234] Port of udp server to bind to\n   * @param {boolean} [customOptions.exclusive=false] Exclusive flag\n   */\n  open(customOptions = {}) {\n    const options = Object.assign({}, this.options.open, customOptions)\n    const { port, exclusive } = options\n\n    this.socketStatus = STATUS.IS_CONNECTING\n\n    this.socket.bind({\n      address: options.host,\n      port,\n      exclusive,\n    }, () => {\n      this.socketStatus = STATUS.IS_OPEN\n      this.notify('open')\n    })\n  }\n\n  /**\n   * Close udp socket\n   */\n  close() {\n    this.socketStatus = STATUS.IS_CLOSING\n\n    this.socket.close(() => {\n      this.socketStatus = STATUS.IS_CLOSED\n      this.notify('close')\n    })\n  }\n\n  /**\n   * Send an OSC Packet, Bundle or Message. Use options here for\n   * custom port and hostname, otherwise the global options will\n   * be taken\n   * @param {Uint8Array} binary Binary representation of OSC Packet\n   * @param {object} [customOptions] Custom options for udp socket\n   * @param {string} [customOptions.host] Hostname of udp client\n   * @param {number} [customOptions.port] Port of udp client\n   */\n  send(binary, customOptions = {}) {\n    const options = Object.assign({}, this.options.send, customOptions)\n    const { port, host } = options\n\n    this.socket.send(Buffer.from(binary), 0, binary.byteLength, port, host)\n  }\n}\n","const dgram = typeof __dirname !== 'undefined' ? require('dgram') : undefined\nconst WebSocketServer = typeof __dirname !== 'undefined' ? require('isomorphic-ws').Server : undefined\n\n/**\n * Status flags\n * @private\n */\nconst STATUS = {\n  IS_NOT_INITIALIZED: -1,\n  IS_CONNECTING: 0,\n  IS_OPEN: 1,\n  IS_CLOSING: 2,\n  IS_CLOSED: 3,\n}\n\n/**\n * Default options\n * @private\n */\nconst defaultOptions = {\n  udpServer: {\n    host: 'localhost',\n    port: 41234,\n    exclusive: false,\n  },\n  udpClient: {\n    host: 'localhost',\n    port: 41235,\n  },\n  wsServer: {\n    host: 'localhost',\n    port: 8080,\n  },\n  receiver: 'ws',\n}\n\n/**\n * Helper method to merge nested objects\n * @private\n */\nfunction mergeOptions(base, custom) {\n  return Object.assign({}, defaultOptions, base, custom, {\n    udpServer: Object.assign({}, defaultOptions.udpServer, base.udpServer, custom.udpServer),\n    udpClient: Object.assign({}, defaultOptions.udpClient, base.udpClient, custom.udpClient),\n    wsServer: Object.assign({}, defaultOptions.wsServer, base.wsServer, custom.wsServer),\n  })\n}\n\n/**\n * OSC plugin for setting up communication between a Websocket\n * client and a udp client with a bridge inbetween\n */\nexport default class BridgePlugin {\n  /**\n   * Create an OSC Bridge instance with given options. Defaults to\n   * localhost:41234 for udp server, localhost:41235 for udp client and\n   * localhost:8080 for Websocket server\n   * @param {object} [options] Custom options\n   * @param {string} [options.udpServer.host='localhost'] Hostname of udp server to bind to\n   * @param {number} [options.udpServer.port=41234] Port of udp server to bind to\n   * @param {boolean} [options.udpServer.exclusive=false] Exclusive flag\n   * @param {string} [options.udpClient.host='localhost'] Hostname of udp client for messaging\n   * @param {number} [options.udpClient.port=41235] Port of udp client for messaging\n   * @param {string} [options.wsServer.host='localhost'] Hostname of Websocket server\n   * @param {number} [options.wsServer.port=8080] Port of Websocket server\n   * @param {string} [options.receiver='ws'] Where messages sent via 'send' method will be\n   * delivered to, 'ws' for Websocket clients, 'udp' for udp client\n   *\n   * @example\n   * const plugin = new OSC.BridgePlugin({ wsServer: { port: 9912 } })\n   * const osc = new OSC({ plugin: plugin })\n   */\n  constructor(customOptions = {}) {\n    if (!dgram || !WebSocketServer) {\n      throw new Error('BridgePlugin can not be used in browser context')\n    }\n\n    /** @type {object} options\n     * @private\n     */\n    this.options = mergeOptions({}, customOptions)\n\n    /**\n     * @type {object} websocket\n     * @private\n     */\n    this.websocket = null\n\n    /**\n     * @type {object} socket\n     * @private\n     */\n    this.socket = dgram.createSocket('udp4')\n    /**\n     * @type {number} socketStatus\n     * @private\n     */\n    this.socketStatus = STATUS.IS_NOT_INITIALIZED\n\n    // register udp events\n    this.socket.on('message', (message) => {\n      this.send(message, { receiver: 'ws' })\n      this.notify(message.buffer)\n    })\n\n    this.socket.on('error', (error) => {\n      this.notify('error', error)\n    })\n\n    /**\n     * @type {function} notify\n     * @private\n     */\n    this.notify = () => {}\n  }\n\n  /**\n   * Internal method to hook into osc library's\n   * EventHandler notify method\n   * @param {function} fn Notify callback\n   * @private\n   */\n  registerNotify(fn) {\n    this.notify = fn\n  }\n\n  /**\n   * Returns the current status of the connection\n   * @return {number} Status ID\n   */\n  status() {\n    return this.socketStatus\n  }\n\n  /**\n   * Bind a udp socket to a hostname and port\n   * @param {object} [customOptions] Custom options\n   * @param {string} [customOptions.host='localhost'] Hostname of udp server to bind to\n   * @param {number} [customOptions.port=41234] Port of udp server to bind to\n   * @param {boolean} [customOptions.exclusive=false] Exclusive flag\n   */\n  open(customOptions = {}) {\n    const options = mergeOptions(this.options, customOptions)\n\n    this.socketStatus = STATUS.IS_CONNECTING\n\n    // bind udp server\n    this.socket.bind({\n      address: options.udpServer.host,\n      port: options.udpServer.port,\n      exclusive: options.udpServer.exclusive,\n    }, () => {\n      // bind Websocket server\n      this.websocket = new WebSocketServer({\n        host: options.wsServer.host,\n        port: options.wsServer.port,\n      })\n      this.websocket.binaryType = 'arraybuffer'\n\n      // register Websocket events\n      this.websocket.on('listening', () => {\n        this.socketStatus = STATUS.IS_OPEN\n        this.notify('open')\n      })\n\n      this.websocket.on('error', (error) => {\n        this.notify('error', error)\n      })\n\n      this.websocket.on('connection', (client) => {\n        client.on('message', (message) => {\n          this.send(message, { receiver: 'udp' })\n          this.notify(new Uint8Array(message))\n        })\n      })\n    })\n  }\n\n  /**\n   * Close udp socket and Websocket server\n   */\n  close() {\n    this.socketStatus = STATUS.IS_CLOSING\n\n    // close udp socket\n    this.socket.close(() => {\n      // close Websocket\n      this.websocket.close(() => {\n        this.socketStatus = STATUS.IS_CLOSED\n        this.notify('close')\n      })\n    })\n  }\n\n  /**\n   * Send an OSC Packet, Bundle or Message. Use options here for\n   * custom receiver, otherwise the global options will be taken\n   * @param {Uint8Array} binary Binary representation of OSC Packet\n   * @param {object} [customOptions] Custom options\n   * @param {string} [customOptions.udpClient.host='localhost'] Hostname of udp client for messaging\n   * @param {number} [customOptions.udpClient.port=41235] Port of udp client for messaging\n   * @param {string} [customOptions.receiver='ws'] Messages will be delivered to Websocket ('ws')\n   * clients or udp client ('udp')\n   */\n  send(binary, customOptions = {}) {\n    const options = mergeOptions(this.options, customOptions)\n    const { receiver } = options\n\n    if (receiver === 'udp') {\n      // send data to udp client\n      const data = binary instanceof Buffer ? binary : Buffer.from(binary)\n      this.socket.send(\n        data,\n        0,\n        data.byteLength,\n        options.udpClient.port,\n        options.udpClient.host,\n      )\n    } else if (receiver === 'ws') {\n      // send data to all Websocket clients\n      this.websocket.clients.forEach((client) => {\n        client.send(binary, { binary: true })\n      })\n    } else {\n      throw new Error('BridgePlugin can not send message to unknown receiver')\n    }\n  }\n}\n","// eslint-disable-next-line no-undef\nconst scope = typeof global === 'undefined' ? window : global\nconst WebSocket = typeof __dirname === 'undefined' ? scope.WebSocket : require('isomorphic-ws')\n\n/**\n * Status flags\n * @private\n */\nconst STATUS = {\n  IS_NOT_INITIALIZED: -1,\n  IS_CONNECTING: 0,\n  IS_OPEN: 1,\n  IS_CLOSING: 2,\n  IS_CLOSED: 3,\n}\n\n/**\n * Default options\n * @private\n */\nconst defaultOptions = {\n  host: 'localhost',\n  port: 8080,\n  secure: false,\n}\n\n/**\n * OSC plugin for a Websocket client running in node or browser context\n */\nexport default class WebsocketClientPlugin {\n  /**\n   * Create an OSC WebsocketClientPlugin instance with given options.\n   * Defaults to *localhost:8080* for connecting to a Websocket server\n   * @param {object} [options] Custom options\n   * @param {string} [options.host='localhost'] Hostname of Websocket server\n   * @param {number} [options.port=8080] Port of Websocket server\n   * @param {boolean} [options.secure=false] Use wss:// for secure connections\n   *\n   * @example\n   * const plugin = new OSC.WebsocketClientPlugin({ port: 9912 })\n   * const osc = new OSC({ plugin: plugin })\n   */\n  constructor(customOptions) {\n    if (!WebSocket) {\n      throw new Error('WebsocketClientPlugin can\\'t find a WebSocket class')\n    }\n\n    /**\n     * @type {object} options\n     * @private\n     */\n    this.options = Object.assign({}, defaultOptions, customOptions)\n\n    /**\n     * @type {object} socket\n     * @private\n     */\n    this.socket = null\n    /**\n     * @type {number} socketStatus\n     * @private\n     */\n    this.socketStatus = STATUS.IS_NOT_INITIALIZED\n\n    /**\n     * @type {function} notify\n     * @private\n     */\n    this.notify = () => {}\n  }\n\n  /**\n   * Internal method to hook into osc library's\n   * EventHandler notify method\n   * @param {function} fn Notify callback\n   * @private\n   */\n  registerNotify(fn) {\n    this.notify = fn\n  }\n\n  /**\n   * Returns the current status of the connection\n   * @return {number} Status identifier\n   */\n  status() {\n    return this.socketStatus\n  }\n\n  /**\n   * Connect to a Websocket server. Defaults to global options\n   * @param {object} [customOptions] Custom options\n   * @param {string} [customOptions.host] Hostname of Websocket server\n   * @param {number} [customOptions.port] Port of Websocket server\n   * @param {boolean} [customOptions.secure] Use wss:// for secure connections\n   */\n  open(customOptions = {}) {\n    const options = Object.assign({}, this.options, customOptions)\n    const { port, host, secure } = options\n\n    // close socket when already given\n    if (this.socket) {\n      this.close()\n    }\n\n    // create websocket client\n    const protocol = secure ? 'wss' : 'ws'\n    this.socket = new WebSocket(`${protocol}://${host}:${port}`)\n    this.socket.binaryType = 'arraybuffer'\n    this.socketStatus = STATUS.IS_CONNECTING\n\n    // register events\n    this.socket.onopen = () => {\n      this.socketStatus = STATUS.IS_OPEN\n      this.notify('open')\n    }\n\n    this.socket.onclose = () => {\n      this.socketStatus = STATUS.IS_CLOSED\n      this.notify('close')\n    }\n\n    this.socket.onerror = (error) => {\n      this.notify('error', error)\n    }\n\n    this.socket.onmessage = (message) => {\n      this.notify(message.data)\n    }\n  }\n\n  /**\n   * Close Websocket\n   */\n  close() {\n    this.socketStatus = STATUS.IS_CLOSING\n    this.socket.close()\n  }\n\n  /**\n   * Send an OSC Packet, Bundle or Message to Websocket server\n   * @param {Uint8Array} binary Binary representation of OSC Packet\n   */\n  send(binary) {\n    this.socket.send(binary)\n  }\n}\n","const WebSocketServer = typeof __dirname !== 'undefined' ? require('isomorphic-ws').Server : undefined\n\n/**\n * Status flags\n * @private\n */\nconst STATUS = {\n  IS_NOT_INITIALIZED: -1,\n  IS_CONNECTING: 0,\n  IS_OPEN: 1,\n  IS_CLOSING: 2,\n  IS_CLOSED: 3,\n}\n\n/**\n * Default options\n * @private\n */\nconst defaultOptions = {\n  host: 'localhost',\n  port: 8080,\n}\n\n/**\n * OSC plugin for a Websocket client running in node or browser context\n */\nexport default class WebsocketServerPlugin {\n  /**\n   * Create an OSC WebsocketServerPlugin instance with given options.\n   * Defaults to *localhost:8080* for the Websocket server\n   * @param {object} [options] Custom options\n   * @param {string} [options.host='localhost'] Hostname of Websocket server\n   * @param {number} [options.port=8080] Port of Websocket server\n   *\n   * @example\n   * const plugin = new OSC.WebsocketServerPlugin({ port: 9912 })\n   * const osc = new OSC({ plugin: plugin })\n   *\n   * osc.open() // start server\n   */\n  constructor(customOptions) {\n    if (!WebSocketServer) {\n      throw new Error('WebsocketServerPlugin can not be used in browser context')\n    }\n\n    /**\n     * @type {object} options\n     * @private\n     */\n    this.options = Object.assign({}, defaultOptions, customOptions)\n\n    /**\n     * @type {object} socket\n     * @private\n     */\n    this.socket = null\n    /**\n     * @type {number} socketStatus\n     * @private\n     */\n    this.socketStatus = STATUS.IS_NOT_INITIALIZED\n\n    /**\n     * @type {function} notify\n     * @private\n     */\n    this.notify = () => {}\n  }\n\n  /**\n   * Internal method to hook into osc library's\n   * EventHandler notify method\n   * @param {function} fn Notify callback\n   * @private\n   */\n  registerNotify(fn) {\n    this.notify = fn\n  }\n\n  /**\n   * Returns the current status of the connection\n   * @return {number} Status identifier\n   */\n  status() {\n    return this.socketStatus\n  }\n\n  /**\n   * Start a Websocket server. Defaults to global options\n   * @param {object} [customOptions] Custom options\n   * @param {string} [customOptions.host] Hostname of Websocket server\n   * @param {number} [customOptions.port] Port of Websocket server\n   */\n  open(customOptions = {}) {\n    const options = Object.assign({}, this.options, customOptions)\n    const { port, host } = options\n\n    // close socket when already given\n    if (this.socket) {\n      this.close()\n    }\n\n    // create websocket server\n    this.socket = new WebSocketServer({ host, port })\n    this.socket.binaryType = 'arraybuffer'\n    this.socketStatus = STATUS.IS_CONNECTING\n\n    // register events\n    this.socket.on('listening', () => {\n      this.socketStatus = STATUS.IS_OPEN\n      this.notify('open')\n    })\n\n    this.socket.on('error', (error) => {\n      this.notify('error', error)\n    })\n\n    this.socket.on('connection', (client) => {\n      client.on('message', (message) => {\n        this.notify(new Uint8Array(message))\n      })\n    })\n  }\n\n  /**\n   * Close Websocket server\n   */\n  close() {\n    this.socketStatus = STATUS.IS_CLOSING\n\n    this.socket.close(() => {\n      this.socketStatus = STATUS.IS_CLOSED\n      this.notify('close')\n    })\n  }\n\n  /**\n   * Send an OSC Packet, Bundle or Message to Websocket clients\n   * @param {Uint8Array} binary Binary representation of OSC Packet\n   */\n  send(binary) {\n    this.socket.clients.forEach((client) => {\n      client.send(binary, { binary: true })\n    })\n  }\n}\n","import {\n  isFunction,\n  isInt,\n  isObject,\n  isString,\n} from './common/utils'\n\nimport Bundle from './bundle'\nimport EventHandler from './events'\nimport Message from './message'\nimport Packet from './packet'\n\nimport DatagramPlugin from './plugin/dgram'\nimport BridgePlugin from './plugin/bridge'\nimport WebsocketClientPlugin from './plugin/wsclient'\nimport WebsocketServerPlugin from './plugin/wsserver'\n\n/**\n * Default options\n * @private\n */\nconst defaultOptions = {\n  discardLateMessages: false,\n  plugin: new WebsocketClientPlugin(),\n}\n\n/**\n * Status flags\n */\nconst STATUS = {\n  IS_NOT_INITIALIZED: -1,\n  IS_CONNECTING: 0,\n  IS_OPEN: 1,\n  IS_CLOSING: 2,\n  IS_CLOSED: 3,\n}\n\n/**\n * OSC interface to send OSC Packets and listen to status changes and\n * incoming message events. Offers a Plugin API for different network\n * protocols, defaults to a simple Websocket client for OSC communication\n * between a browser js-app and a js-node server\n *\n * @example\n * const osc = new OSC()\n *\n * osc.on('/input/test', message => {\n *   // print incoming OSC message arguments\n *   console.log(message.args)\n * })\n *\n * osc.on('open', () => {\n *   const message = new Message('/test/path', 55.12, 'hello')\n *   osc.send(message)\n * })\n *\n * osc.open({ host: '192.168.178.115', port: 9012 })\n */\nclass OSC {\n  /**\n   * Create an OSC instance with given options\n   * @param {object} [options] Custom options\n   * @param {boolean} [options.discardLateMessages=false] Ignore incoming\n   * messages when given timetag lies in the past\n   * @param {Plugin} [options.plugin=WebsocketClientPlugin] Add a connection plugin\n   * to this interface, defaults to a plugin with Websocket client.\n   * Open README.md for further information on how to handle plugins or\n   * how to write your own with the Plugin API\n   *\n   * @example\n   * const osc = new OSC() // default options with Websocket client\n   *\n   * @example\n   * const osc = new OSC({ discardLateMessages: true })\n   *\n   * @example\n   * const websocketPlugin = new OSC.WebsocketClientPlugin()\n   * const osc = new OSC({ plugin: websocketPlugin })\n   */\n  constructor(options) {\n    if (options && !isObject(options)) {\n      throw new Error('OSC options argument has to be an object.')\n    }\n\n    /**\n     * @type {object} options\n     * @private\n     */\n    this.options = Object.assign({}, defaultOptions, options)\n    /**\n     * @type {EventHandler} eventHandler\n     * @private\n     */\n    this.eventHandler = new EventHandler({\n      discardLateMessages: this.options.discardLateMessages,\n    })\n\n    // pass EventHandler's notify() to plugin\n    const { eventHandler } = this\n    if (this.options.plugin && this.options.plugin.registerNotify) {\n      this.options.plugin.registerNotify((...args) => eventHandler.notify(...args))\n    }\n  }\n\n  /**\n   * Listen to a status-change event or incoming OSC message with\n   * address pattern matching\n   * @param {string} eventName Event name or OSC address pattern\n   * @param {function} callback Function which is called on notification\n   * @return {number} Subscription id (needed to unsubscribe)\n   *\n   * @example\n   * // will be called when server receives /in!trument/* for example\n   * osc.on('/instrument/1', message => {\n   *   console.log(message)\n   * })\n   *\n   * @example\n   * // will be called for every message since it uses the wildcard symbol\n   * osc.on('*', message => {\n   *   console.log(message)\n   * })\n   *\n   * @example\n   * // will be called on network socket error\n   * osc.on('error', message => {\n   *   console.log(message)\n   * })\n   */\n  on(eventName, callback) {\n    if (!(isString(eventName) && isFunction(callback))) {\n      throw new Error('OSC on() needs event- or address string and callback function')\n    }\n\n    return this.eventHandler.on(eventName, callback)\n  }\n\n  /**\n   * Unsubscribe an event listener\n   * @param {string} eventName Event name or OSC address pattern\n   * @param {number} subscriptionId The subscription id\n   * @return {boolean} Success state\n   *\n   * @example\n   * const listenerId = osc.on('error', message => {\n   *   console.log(message)\n   * })\n   * osc.off('error', listenerId) // unsubscribe from error event\n   */\n  off(eventName, subscriptionId) {\n    if (!(isString(eventName) && isInt(subscriptionId))) {\n      throw new Error('OSC off() needs string and number (subscriptionId) to unsubscribe')\n    }\n\n    return this.eventHandler.off(eventName, subscriptionId)\n  }\n\n  /**\n   * Open network socket with plugin. This method is used by\n   * plugins and is not available without (see Plugin API for more information)\n   * @param {object} [options] Custom global options for plugin instance\n   *\n   * @example\n   * const osc = new OSC({ plugin: new OSC.DatagramPlugin() })\n   * osc.open({ host: '127.0.0.1', port: 8080 })\n   */\n  open(options) {\n    if (options && !isObject(options)) {\n      throw new Error('OSC open() options argument needs to be an object')\n    }\n\n    if (!(this.options.plugin && isFunction(this.options.plugin.open))) {\n      throw new Error('OSC Plugin API #open is not implemented!')\n    }\n\n    return this.options.plugin.open(options)\n  }\n\n  /**\n   * Returns the current status of the connection. See *STATUS* for\n   * different possible states. This method is used by plugins\n   * and is not available without (see Plugin API for more information)\n   * @return {number} Status identifier\n   *\n   * @example\n   * import OSC, { STATUS } from 'osc'\n   * const osc = new OSC()\n   * if (osc.status() === STATUS.IS_CONNECTING) {\n   *   // do something\n   * }\n   */\n  status() {\n    if (!(this.options.plugin && isFunction(this.options.plugin.status))) {\n      throw new Error('OSC Plugin API #status is not implemented!')\n    }\n\n    return this.options.plugin.status()\n  }\n\n  /**\n   * Close connection. This method is used by plugins and is not\n   * available without (see Plugin API for more information)\n   */\n  close() {\n    if (!(this.options.plugin && isFunction(this.options.plugin.close))) {\n      throw new Error('OSC Plugin API #close is not implemented!')\n    }\n\n    return this.options.plugin.close()\n  }\n\n  /**\n   * Send an OSC Packet, Bundle or Message. This method is used by plugins\n   * and is not available without (see Plugin API for more information)\n   * @param {Packet|Bundle|Message} packet OSC Packet, Bundle or Message instance\n   * @param {object} [options] Custom options\n   *\n   * @example\n   * const osc = new OSC({ plugin: new OSC.DatagramPlugin() })\n   * osc.open({ host: '127.0.0.1', port: 8080 })\n   *\n   * const message = new OSC.Message('/test/path', 55.1, 57)\n   * osc.send(message)\n   *\n   * // send message again to custom address\n   * osc.send(message, { host: '192.168.178.115', port: 9001 })\n   */\n  send(packet, options) {\n    if (!(this.options.plugin && isFunction(this.options.plugin.send))) {\n      throw new Error('OSC Plugin API #send is not implemented!')\n    }\n\n    if (!(packet instanceof Message || packet instanceof Bundle || packet instanceof Packet)) {\n      throw new Error('OSC send() needs Messages, Bundles or Packets')\n    }\n\n    if (options && !isObject(options)) {\n      throw new Error('OSC send() options argument has to be an object')\n    }\n\n    return this.options.plugin.send(packet.pack(), options)\n  }\n}\n\n// expose status flags\nOSC.STATUS = STATUS\n\n// expose OSC classes\nOSC.Packet = Packet\nOSC.Bundle = Bundle\nOSC.Message = Message\n\n// expose plugins\nOSC.DatagramPlugin = DatagramPlugin\nOSC.WebsocketClientPlugin = WebsocketClientPlugin\nOSC.WebsocketServerPlugin = WebsocketServerPlugin\nOSC.BridgePlugin = BridgePlugin\n\nexport default OSC\n"],"names":["isInt","n","Number","isFloat","isString","isArray","Object","prototype","toString","call","isObject","isFunction","isBlob","Uint8Array","isUndefined","pad","hasProperty","name","hasOwnProperty","global","window","typeTag","item","Error","prepareAddress","obj","address","join","length","slice","prepareRegExPattern","str","replace","EncodeHelper","data","byteLength","buffer","pack","push","this","result","offset","forEach","set","Atomic","value","method","dataView","DataView","initialOffset","AtomicInt32","STR_ENCODING","AtomicString","terminated","i","charCodeAt","charcode","charCodes","getUint8","Buffer","from","TextDecoder","decode","Int8Array","String","fromCharCode","apply","charCodesToString","SECONDS_70_YEARS","TWO_POWER_32","Timetag","seconds","fractions","milliseconds","Math","round","rounded","floor","AtomicTimetag","Date","now","timetag","timestamp","getTime","setInt32","getUint32","AtomicBlob","getInt32","AtomicFloat32","Message","types","args","shift","map","argument","encoder","Helper","add","merge","unpack","next","type","BUNDLE_TAG","Bundle","bundleElements","_this","ms","parentHead","head","Packet","defaultOptions","discardLateMessages","EventHandler","options","assign","addressHandlers","eventHandlers","open","error","close","uuid","packet","bundle","bundleItem","dispatch","message","notify","success","handler","callback","handlerKeys","keys","handlers","key","foundMatch","regex","RegExp","test","lastIndex","reverseRegex","ArrayBuffer","that","setTimeout","id","subscriptionId","haystack","some","index","splice","dgram","__dirname","require","undefined","STATUS","host","port","exclusive","send","DatagramPlugin","base","custom","customOptions","socket","createSocket","socketStatus","on","fn","bind","_this2","_this3","binary","WebSocketServer","Server","udpServer","udpClient","wsServer","receiver","mergeOptions","BridgePlugin","websocket","binaryType","client","clients","scope","WebSocket","secure","WebsocketClientPlugin","protocol","onopen","onclose","onerror","onmessage","WebsocketServerPlugin","plugin","OSC","eventHandler","registerNotify","eventName","off","status","IS_NOT_INITIALIZED","IS_CONNECTING","IS_OPEN","IS_CLOSING","IS_CLOSED"],"mappings":"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"}